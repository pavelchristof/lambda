-- Function application.
let $ = λf.λx.f x;

-- Function composition.
let . = λf.λg.λx.f (g x);

-- Absolute value.
let abs = λx.
    if (x >= 0)
        x
        (0 - x);

-- Fibonacci!
let rec fib = λx.
    if (x <= 1)
        1
        ((fib (x - 1)) + (fib (x - 2)));

-- Concatenates two lists.
let rec ++ = λl.λr.
        if (null l)
            r
            ((tail l) ++ ((head l):r));

-- Right fold.
let foldr = λk.λz.
    let rec go = λl.
        if (null l)
            z
            (k (head l) (go (tail l)))
    in go;

-- String to int conversion.
let digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
let indexOf = λe.
    let rec indexOf' = λi.λl.
        if ((head l) == e)
            i
            (indexOf' (i + 1) (tail l))
    in  indexOf' 0;
let strToInt = foldr (λc.λn. (10*n) + (indexOf c digits)) 0;

-- Sum elements of a list while converting strings to ints.
printInt $ foldr (λe.((+) (strToInt e))) 0 (["123", "543"] ++ ["42", "18"]);

-- Fixed-point combinator.
let fix = λf.
    let rec x = f x
    in  x;
    
let alwaysFive = λx.5;
printInt (fix alwaysFive);

-- Top level expressions are evaluated to WHNF form. 
-- These numbers won't be printed due to laziness.
[printInt 123, printInt 543];

-- seq can be used to force objects to be evaulted to WHNF form.
let list = [seq (printStr "Hello world!\n") ()]
in  head list;

-- The same with no seq.
let noseq = λx.λy.y;
let list = [noseq (printStr "Goodbye world!\n") ()]
in  head list;
